import { Component, Input, HostBinding } from '@angular/core';
/**
 * Display custom or validation messages.
 *
 * @example
 * <tzf-message message="An error occurred."></tzf-message>
 *
 * @example
 * <form #myForm="ngForm">
 *   <tzf-message
 *     form="myForm"
 *     validationMessages="valMsgs"
 *   ></tzf-message>
 *   <input type="text"
 *     [(ngModel)]="field1"
 *     name="field1"
 *     required
 *   >
 * </form>
 *
 * @example
 * validationMessages = {
 *   field1: {
 *     required: 'Field #1 is required.',
 *   },
 * };
 */
var MessageComponent = (function () {
    function MessageComponent() {
        /**
         * The message type.
         */
        this.type = 'error';
        /**
         * Icons for the different message types.
         */
        this.icons = {
            error: 'assets/common/icons/icon_hide.svg',
            success: 'assets/common/icons/icon_tick.svg',
        };
        this._messages = [];
        this.valMessages = [];
    }
    /**
     * When a form is set, add hooks to detect validation changes.
     */
    MessageComponent.prototype.ngOnChanges = function (changes) {
        var _this = this;
        if (changes.message) {
            this._messages = this.message ? [this.message] : [];
        }
        else if (changes.messages) {
            this._messages = this.messages || [];
        }
        var form = this.form;
        if (changes.form && form) {
            var updateMessages_1 = function () {
                var messages = _this.valMessages = [];
                if (form.invalid) {
                    var valMsgs = _this.validationMessages;
                    for (var controlName in valMsgs) {
                        var control = form.controls[controlName];
                        if (!control) {
                            console.warn('Validation message for non-existant control: ' + controlName);
                            continue;
                        }
                        if (control.errors && control.touched) {
                            var controlMessages = valMsgs[controlName];
                            for (var validator in controlMessages) {
                                if (control.errors[validator]) {
                                    messages.push(controlMessages[validator]);
                                }
                            }
                        }
                    }
                }
            };
            // There is no hook for the touched event so patch one in.
            // Consider refactoring into replacement for FormControl.
            for (var controlName in form.controls) {
                var control = form.controls[controlName];
                control._tzf_markAsTouched = control.markAsTouched;
                control.markAsTouched = function (onlySelf) {
                    this._tzf_markAsTouched(onlySelf);
                    updateMessages_1();
                };
            }
            form.statusChanges.subscribe(updateMessages_1);
        }
    };
    MessageComponent.decorators = [
        { type: Component, args: [{
                    selector: 'tzf-message',
                    template: "<div *ngIf=\"_messages.length || valMessages.length\" role=\"alert\" [inlineSVG]=\"icons[type]\" [prepend]=\"true\" > <ul> <li *ngFor=\"let valMsg of valMessages\" translate>{{ valMsg }}</li> <li *ngFor=\"let msg of _messages\" translate>{{ msg }}</li> </ul> </div> ",
                    styles: ["div{border:2px solid;border-radius:3px;display:inline-block;min-width:60%;max-width:800px;padding:.8em 1.5em;margin-bottom:1em}div ::ng-deep svg{float:left;height:1.5em;width:1.5em}:host.error div{background:#fff3f7;border-color:#ee7b94;color:#d90c38}:host.success div{background:#ebf4e4;border-color:#7d9b76;color:#386830}:host ::ng-deep path{fill:currentColor}ul{margin:0 0 0 3em}"]
                },] },
    ];
    /** @nocollapse */
    MessageComponent.ctorParameters = function () { return []; };
    MessageComponent.propDecorators = {
        'validationMessages': [{ type: Input },],
        'form': [{ type: Input },],
        'messages': [{ type: Input },],
        'message': [{ type: Input },],
        'type': [{ type: HostBinding, args: ['class',] }, { type: Input },],
    };
    return MessageComponent;
}());
export { MessageComponent };
//# sourceMappingURL=message.component.js.map