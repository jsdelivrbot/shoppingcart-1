var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
import { Component, ViewChild, HostListener, Input, Output, EventEmitter, forwardRef } from '@angular/core';
import { DomUtilities } from '../../shared/dom.utilities';
import { FormFieldChild } from '../form-field-child';
/**
 * Provide a button in the place of a field to open a large popover with a custom template.
 *
 * @example
 * <tzf-form-field-popover
 *   [actions]="true"
 *   (prepare)="preparePopoverData()"
 *   (accept)="copyDataFromPopover()"
 *   (reset)="clearPopoverData()"
 * >
 *   I can put whatever content I want here! How about a text box.
 *   <input type="text" [(ngModel)]="popoverData.value">
 * </tzf-form-field-popover>
 */
var FormFieldPopoverComponent = (function (_super) {
    __extends(FormFieldPopoverComponent, _super);
    function FormFieldPopoverComponent() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        /**
         * Display Reset and Done buttons at the bottom of the popover.
         */
        _this.actions = true;
        /**
         * Called before the popover is opened. If necessary, set up the
         * data bound to the fields in the popover.
         */
        _this.prepare = new EventEmitter();
        /**
         * Called when the user has finished using the popover.
         */
        _this.accept = new EventEmitter();
        /**
         * The data bound to the fields in the popover should be reset.
         */
        _this.reset = new EventEmitter();
        /**
         * The popover should be displayed.
         *
         * Initialized to false instead of undefined for aria attributes.
         */
        _this.open = false;
        return _this;
    }
    /**
     * Set up listener for focus events to automatically close the popover.
     * @private
     */
    FormFieldPopoverComponent.prototype.ngOnInit = function () {
        var _this = this;
        var listener = this.docFocusListener = function (event) {
            if (_this.open && _this.toggleButtonRef.nativeElement !== event.target && !_this.popoverEl.contains(event.target)) {
                _this.doAccept(false);
            }
        };
        document.addEventListener('focus', listener, true);
    };
    /**
     * Remove the focus event listener.
     * @private
     */
    FormFieldPopoverComponent.prototype.ngOnDestroy = function () {
        document.removeEventListener('focus', this.docFocusListener);
    };
    /**
     * Accept the edits in the popover and close it.
     */
    FormFieldPopoverComponent.prototype.doAccept = function (focusToggleOnClose) {
        this.accept.emit();
        this.close(focusToggleOnClose);
    };
    /**
     * Reset the data in the popover and accept it, then close it.
     */
    FormFieldPopoverComponent.prototype.doReset = function () {
        this.reset.emit();
        this.accept.emit();
        this.close();
    };
    /**
     * Close the popover and return focus to the toggle button if desired.
     */
    FormFieldPopoverComponent.prototype.close = function (focusToggle) {
        if (focusToggle === void 0) { focusToggle = true; }
        if (focusToggle) {
            this.toggleButtonRef.nativeElement.focus();
        }
        this.open = false;
    };
    /**
     * Close the popup when Escape is pressed.
     */
    FormFieldPopoverComponent.prototype.closeOnEsc = function (event) {
        if (this.open) {
            if (event.key === 'Escape') {
                this.close();
            }
        }
    };
    /**
     * Act as if Done was clicked when Enter is pressed.
     */
    FormFieldPopoverComponent.prototype.closeOnEnter = function (event) {
        if (event.key === 'Enter') {
            this.doAccept();
            return false;
        }
    };
    /**
     * Open or close the popover.
     */
    FormFieldPopoverComponent.prototype.toggle = function () {
        if (this.open = !this.open) {
            this.prepare.emit();
            this.keepPopoverOnScreen();
            this.autoFocus();
        }
        else {
            this.popoverEl.style.right = 0;
            this.doAccept();
        }
    };
    /**
     * Attempt to focus on the first field in the popover.
     */
    FormFieldPopoverComponent.prototype.autoFocus = function () {
        var _this = this;
        setTimeout(function () {
            var inputs = _this.popoverEl.getElementsByTagName('input');
            if (inputs.length) {
                inputs[0].select();
            }
        });
    };
    /**
     * Check if the popover is wide enough to go offscreen
     * and move to the left enough to bring it back on.
     */
    FormFieldPopoverComponent.prototype.keepPopoverOnScreen = function () {
        if (this.open) {
            var popoverEl = this.popoverEl;
            var windowWidth = document.documentElement.clientWidth;
            // Reset before computing
            popoverEl.style.maxWidth = windowWidth + 'px';
            // Update the position
            var popoverRightCoordinate = popoverEl.offsetWidth + DomUtilities.getAbsoluteOffset(popoverEl.offsetParent).left;
            popoverEl.style.left = (popoverRightCoordinate > windowWidth) ? windowWidth - popoverRightCoordinate - 1 + 'px' : '-1px';
            popoverEl.style.right = 'auto';
        }
    };
    Object.defineProperty(FormFieldPopoverComponent.prototype, "popoverEl", {
        /**
         * Get the popover container's native element.
         */
        get: function () {
            return this.popoverRef.nativeElement;
        },
        enumerable: true,
        configurable: true
    });
    FormFieldPopoverComponent.decorators = [
        { type: Component, args: [{
                    selector: 'tzf-form-field-popover',
                    template: "<div [tzfClickOutside]=\"open\" [ignoreOrphanTargetClicks]=\"true\" (clickOutside)=\"doAccept()\" > <ng-content select=\"input\"></ng-content> <button #toggleButton class=\"toggle\" type=\"button\" (click)=\"toggle()\" [disabled]=\"disabled\" [attr.aria-expanded]=\"open\" [attr.aria-controls]=\"id && id + '-popover'\" [attr.tabindex]=\"disableToggleKeyAccess && -1\" > <ng-content select=\"[button]\"></ng-content> <div class=\"caret\" [class.active]=\"open\"></div> </button> <fieldset #popover [attr.id]=\"id && id + '-popover'\" (window:resize)=\"keepPopoverOnScreen()\" [attr.aria-hidden]=\"!open\" > <legend><!-- Should label be duplicated here? --></legend> <div class=\"popover\"> <div class=\"content\" (keypress)=\"closeOnEnter($event)\"> <ng-content select=\"[content]\"></ng-content> </div> <div class=\"actions\" *ngIf=\"actions\"> <button type=\"button\" [attr.id]=\"id && id + '-resetBtn'\" class=\"cancel\" (click)=\"doReset()\" >Clear</button> <button type=\"button\" [attr.id]=\"id && id + '-acceptBtn'\" class=\"accept\" (click)=\"doAccept()\" >Done</button> </div> </div> </fieldset> </div> ",
                    styles: [":root{--side-padding:50px}@media (max-width:1000px){:root{--side-padding:5vw}}div ::ng-deep>input{background:transparent!important;border-bottom-color:transparent!important;display:block;margin-bottom:-26px;position:relative;width:auto;z-index:1;left:-1.5em;padding-left:1.5em!important}.toggle{padding-right:1.5em!important;position:relative}.toggle .caret{pointer-events:none;position:absolute;right:16px;top:50%;transform:translateY(-4px) scale(1);transition:transform .2s ease-out}.toggle .caret.active{transform:translateY(3px) scaleY(-1)}.toggle .caret:before{border-top:7px solid currentColor;border-left:7px solid transparent;border-right:7px solid transparent;content:'';position:absolute;top:0;left:0}.toggle .caret:after{border-top:5px solid #fff;border-left:5px solid transparent;border-right:5px solid transparent;content:'';position:absolute;left:2px;top:0}.actions button,.toggle{cursor:pointer}fieldset{height:0;overflow:hidden;padding:0 50px 1.5em 0;padding-right:var(--side-padding);position:absolute;right:0;top:100%;visibility:hidden;display:block;z-index:2;box-sizing:content-box;min-width:101%}:host-context([tzfFormField]:last-child) fieldset{left:auto!important;right:-1px!important;padding-right:0}legend{height:0;margin:0;overflow:hidden;width:0}.popover{background:#fff;border:1px solid #c2cbd4;box-shadow:0 3px rgba(0,0,0,.1)}.content{overflow:auto}.content ::ng-deep>div{padding:1.5em}[aria-hidden=false]{height:auto;right:auto;visibility:visible;opacity:1}.actions{background-color:#f1f8fd;border-top:1px solid #aad0ea;padding:1.2em 1.5em 1.5em;text-align:right}.actions button{border:none;background:none;padding:0}.cancel{color:#5d5d5d;float:left;margin-top:1px}.accept{color:#257f8e;font-weight:700}"],
                    providers: [
                        {
                            provide: FormFieldChild,
                            useExisting: forwardRef(function () { return FormFieldPopoverComponent; })
                        }
                    ]
                },] },
    ];
    /** @nocollapse */
    FormFieldPopoverComponent.ctorParameters = function () { return []; };
    FormFieldPopoverComponent.propDecorators = {
        'actions': [{ type: Input },],
        'id': [{ type: Input },],
        'disableToggleKeyAccess': [{ type: Input },],
        'disabled': [{ type: Input },],
        'prepare': [{ type: Output },],
        'accept': [{ type: Output },],
        'reset': [{ type: Output },],
        'popoverRef': [{ type: ViewChild, args: ['popover',] },],
        'toggleButtonRef': [{ type: ViewChild, args: ['toggleButton',] },],
        'closeOnEsc': [{ type: HostListener, args: ['document:keyup', ['$event'],] },],
    };
    return FormFieldPopoverComponent;
}(FormFieldChild));
export { FormFieldPopoverComponent };
//# sourceMappingURL=form-field-popover.component.js.map