import { Directive, ElementRef, Renderer, Input, Host, Optional } from '@angular/core';
import { AccessCheckService } from '../shared/access-check.service';
import { RoleBasedAccessControlApi } from '@tranzform/client-authorization';
import { AccessCheckProvider } from '../shared/access-check-aware';
var ApplyAccessCheckDirective = (function () {
    function ApplyAccessCheckDirective(parent, el, renderer, accessCheckService) {
        var _this = this;
        this.parent = parent;
        this.renderer = renderer;
        this.items = [];
        // wait to process until capabilities are cached
        accessCheckService.getCapabilitesCached().subscribe(function (cache) {
            _this.items = cache;
            _this.applyCapabilityRules(el, accessCheckService);
        });
    }
    ApplyAccessCheckDirective.prototype.applyCapabilityRules = function (el, accessCheckService) {
        var control = el.nativeElement;
        var capabilityKey = control.getAttribute('capability');
        var capabilities = accessCheckService.getCapabilities(capabilityKey);
        // If this is a tzform common control, pass capabilites to control for evaluation
        // This control should be using an interface with the applyAccessControl method implmented.
        if (this.parent) {
            this.parent.applyAccessControl({
                read: capabilities.indexOf('Read') >= 0,
                write: capabilities.indexOf('Write') >= 0,
                update: capabilities.indexOf('Update') >= 0,
                delete: capabilities.indexOf('Delete') >= 0,
            });
            return;
        }
        // disable the element first
        // to prevent the css effect delay caused by the service call
        control.setAttribute('disabled', 'disabled'); // Read Only
        // If no capabilities, remove
        if (!capabilities) {
            // Hide
            this.setDisplayNone(control);
            return;
        }
        if (capabilities && !capabilities.length) {
            // Hide
            this.setDisplayNone(control);
            return;
        }
        if (capabilities && capabilities.length === 1 && capabilities.indexOf('Read') !== -1) {
            // Keep read only attribute
            if (el.nativeElement.type === 'button') {
                // this.removeControl(control); MemberEngage version does this. Not a good angular 2 practice
                this.setDisplayNone(control);
            }
            return;
        }
        // Permission exists but != Read, Write, Update, Delete . Treat as read-only
        if (capabilities && capabilities.length === 1
            && capabilities.indexOf('Read') !== -1
            && capabilities.indexOf('Write') !== -1
            && capabilities.indexOf('Update') !== -1
            && capabilities.indexOf('Delete') !== -1) {
            // Keep read only attribute
            if (el.nativeElement.type === 'button') {
                // this.removeControl(control); MemberEngage version does this. Not a good angular 2 practice
                this.setDisplayNone(control);
            }
            return;
        }
        if (capabilities && capabilities.length && capabilities.length > 1) {
            // Full functionality. Remove read only attribute
            this.removeDisabledAttribute(control);
        }
    };
    ApplyAccessCheckDirective.prototype.setDisplayNone = function (control) {
        control.setAttribute('style', 'display:none');
    };
    ApplyAccessCheckDirective.prototype.removeControl = function (control) {
        control.remove();
    };
    ApplyAccessCheckDirective.prototype.removeDisabledAttribute = function (control) {
        control.removeAttribute('disabled');
    };
    ApplyAccessCheckDirective.prototype.addDisabledAttribute = function (control) {
        control.setAttribute('disabled', 'disabled');
    };
    ApplyAccessCheckDirective.decorators = [
        { type: Directive, args: [{
                    selector: '[tzfApplyAccessCheck]',
                    providers: [RoleBasedAccessControlApi]
                },] },
    ];
    /** @nocollapse */
    ApplyAccessCheckDirective.ctorParameters = function () { return [
        { type: AccessCheckProvider, decorators: [{ type: Optional }, { type: Host },] },
        { type: ElementRef, },
        { type: Renderer, },
        { type: AccessCheckService, },
    ]; };
    ApplyAccessCheckDirective.propDecorators = {
        'capability': [{ type: Input },],
    };
    return ApplyAccessCheckDirective;
}());
export { ApplyAccessCheckDirective };
//# sourceMappingURL=apply-access-check.directive.js.map